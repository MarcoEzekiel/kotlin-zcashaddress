/*
 * This source file was generated by the Gradle 'init' task
 */
package cash.z.zcashaddress

import com.rfksystems.blake2b.Blake2b
import kotlin.math.min
import kotlin.jvm.JvmStatic

private const val MIN_LEN_M = 48
private const val MAX_LEN_M = 4194368
private const val LEN_H = 64

public object F4jumble {
    private fun ceilDiv(num: Int, den: Int): Int {
        return (num + den - 1) / den
    }

    private fun hPers(i: Int): ByteArray {
        return byteArrayOf(
                85,
                65,
                95,
                70,
                52,
                74,
                117,
                109,
                98,
                108,
                101,
                95,
                72,
                i.toByte(),
                0,
                0
        )
    }

    private fun gPers(i: Int, j: Int): ByteArray {
        return byteArrayOf(
                85,
                65,
                95,
                70,
                52,
                74,
                117,
                109,
                98,
                108,
                101,
                95,
                71,
                i.toByte(),
                (j and 0xff).toByte(),
                (j shr 8).toByte()
        )
    }

    private fun xor(x: ByteArray, y: ByteArray): ByteArray {
        val result = ByteArray(x.size)
        for (i in x.indices) {
            if (i < y.size) {
                result.set(i, (x.get(i).toUByte() xor y.get(i).toUByte()).toByte())
            }
        }
        return result
    }

    private fun gRound(i: Int, u: ByteArray, lenR: Int): ByteArray {
        fun inner(j: Int): ByteArray {
            val g = Blake2b(null, LEN_H, null, gPers(i, j))

            g.update(u, 0, u.size)

            val out = ByteArray(64)
            g.digest(out, 0)
            return out
        }

        val result = mutableListOf<Byte>()
        for (j in 0 until ceilDiv(lenR, LEN_H)) {
            val hash = inner(j)
            result.addAll(hash.toList())
        }
        return result.toByteArray().copyOf(lenR)
    }

    private fun hRound(i: Int, u: ByteArray, lenL: Int): ByteArray {
        val h = Blake2b(null, lenL, null, hPers(i))

        h.update(u, 0, u.size)

        val out = ByteArray(lenL)
        h.digest(out, 0)

        return out
    }

    // Encodes the given []byte using F4Jumble, and returns the encoded message as []byte.
    // Returns an error if the message is an invalid length.
    //
    // # Examples
    //
    //	src := []byte{
    //		0x5d, 0x7a, 0x8f, 0x73, 0x9a, 0x2d, 0x9e, 0x94, 0x5b, 0x0c, 0xe1, 0x52, 0xa8, 0x04,
    // 0x9e, 0x29, 0x4c, 0x4d, 0x6e, 0x66, 0xb1, 0x64, 0x93, 0x9d, 0xaf, 0xfa, 0x2e, 0xf6, 0xee,
    // 0x69, 0x21, 0x48, 0x1c, 0xdd, 0x86, 0xb3, 0xcc, 0x43, 0x18, 0xd9, 0x61, 0x4f, 0xc8, 0x20,
    // 0x90, 0x5d, 0x04, 0x2b,
    //	}
    //	jumbled := []byte{
    //		0x03, 0x04, 0xd0, 0x29, 0x14, 0x1b, 0x99, 0x5d, 0xa5, 0x38, 0x7c, 0x12, 0x59, 0x70,
    // 0x67, 0x35, 0x04, 0xd6, 0xc7, 0x64, 0xd9, 0x1e, 0xa6, 0xc0, 0x82, 0x12, 0x37, 0x70, 0xc7,
    // 0x13, 0x9c, 0xcd, 0x88, 0xee, 0x27, 0x36, 0x8c, 0xd0, 0xc0, 0x92, 0x1a, 0x04, 0x44, 0xc8,
    // 0xe5, 0x85, 0x8d, 0x22,
    //	}
    //
    //	val jumbledSrc = F4Jumble.f4Jumble(src)
    //
    //	assertEquals(jumbled, jumbledSrc)
    @JvmStatic
    fun f4Jumble(m: ByteArray): ByteArray {
        val lenM = m.size
        if (lenM < MIN_LEN_M || lenM > MAX_LEN_M) {
            throw IllegalArgumentException("Invalid message length: " + m.size)
        }

        val lenL = min(LEN_H, lenM / 2)
        val lenR = lenM - lenL

        val a = m.copyOfRange(0, lenL)
        val b = m.copyOfRange(lenL, m.size)

        val x = xor(b, gRound(0, a, lenR))
        val y = xor(a, hRound(0, x, lenL))
        val d = xor(x, gRound(1, y, lenR))
        val c = xor(y, hRound(1, d, lenL))

        return (c + d)
    }

    /**
     * Inverts the F4Jumble operation, returning the original un-jumbled bytes.
     * Returns an error if the message is an invalid length.
     *
     * # Examples
     *
     *	src := []byte{
     *		0x5d, 0x7a, 0x8f, 0x73, 0x9a, 0x2d, 0x9e, 0x94, 0x5b, 0x0c, 0xe1, 0x52, 0xa8, 0x04,
     * 0x9e, 0x29, 0x4c, 0x4d, 0x6e, 0x66, 0xb1, 0x64, 0x93, 0x9d, 0xaf, 0xfa, 0x2e, 0xf6, 0xee,
     * 0x69, 0x21, 0x48, 0x1c, 0xdd, 0x86, 0xb3, 0xcc, 0x43, 0x18, 0xd9, 0x61, 0x4f, 0xc8, 0x20,
     * 0x90, 0x5d, 0x04, 0x2b,
     *		}
     *	jumbled := []byte{
     *		0x03, 0x04, 0xd0, 0x29, 0x14, 0x1b, 0x99, 0x5d, 0xa5, 0x38, 0x7c, 0x12, 0x59, 0x70,
     * 0x67, 0x35, 0x04, 0xd6, 0xc7, 0x64, 0xd9, 0x1e, 0xa6, 0xc0, 0x82, 0x12, 0x37, 0x70, 0xc7,
     * 0x13, 0x9c, 0xcd, 0x88, 0xee, 0x27, 0x36, 0x8c, 0xd0, 0xc0, 0x92, 0x1a, 0x04, 0x44, 0xc8,
     * 0xe5, 0x85, 0x8d, 0x22,
     *	}
     *
     *	val unJumbled = F4Jumble.f4JumbleInv(jumbled)
     *
     *	assertEquals(unJumbled,src)
     */
    @JvmStatic
    fun f4JumbleInv(m: ByteArray): ByteArray {
        val lenM = m.size
        if (lenM < MIN_LEN_M || lenM > MAX_LEN_M) {
            throw IllegalArgumentException("Invalid message length")
        }
        val lenL = min(LEN_H, lenM / 2)
        val lenR = lenM - lenL

        val c = m.copyOfRange(0, lenL)
        val d = m.copyOfRange(lenL, m.size)

        val y = xor(c, hRound(1, d, lenL))
        val x = xor(d, gRound(1, y, lenR))
        val a = xor(y, hRound(0, x, lenL))
        val b = xor(x, gRound(0, a, lenR))

        return (a + b)
    }
}
