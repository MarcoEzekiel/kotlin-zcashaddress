/*
 * This source file was generated by the Gradle 'init' task
 */
package cash.z.zcashaddress
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.ExperimentalStdlibApi

@OptIn(ExperimentalStdlibApi::class)
class CompactSize {

    companion object{
        const val maxCompactSize: ULong = 0x2000000u
        fun convertByteToHex(addr: ByteArray): List<String> {
            val hexes = mutableListOf<String>()
            for (byte in addr) {
                val hexVal = byte.toInt().and(0xFF).toString(16)
                // add to uppercase
                hexes.add("0x$hexVal")
            }
            return hexes
        }
        /**  
        * Writes a uint64 value as its CompactSize byte representation.
        *
        * If `allowOutOfRange` is true, this will allow the serialization of
        * values greater than 0x2000000.
        */
        fun writeCompactSize(n: ULong, allowU64: Boolean): ByteArray {
           
        
            if (!allowU64 && n > maxCompactSize) {
                throw IllegalArgumentException("number exceeds maximum compact size")
            }
        
            val outputStream = ByteArrayOutputStream()
            when {
                n < 253u -> {
                    outputStream.write(n.toByte().toInt())
                }
                n <= UShort.MAX_VALUE.toULong() -> {
                    outputStream.write(253)
                    outputStream.write(n.toUShort().toByteArray())
                }
                n <= UInt.MAX_VALUE.toULong() -> {
                    outputStream.write(254)
                    outputStream.write(n.toUInt().toByteArray())
                }
                else -> {
                    outputStream.write(255)
                    outputStream.write(n.toByteArray())
                }
            }
        
            return outputStream.toByteArray()
        }
        
        fun UShort.toByteArray(): ByteArray {
            return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(this.toShort()).array()
        }
        
        fun UInt.toByteArray(): ByteArray {
            return ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(this.toInt()).array()
        }
        
        fun ULong.toByteArray(): ByteArray {
            return ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(this.toLong()).array()
        }
        /** 
        * Reads a uint64 value from its CompactSize byte representation.
        *
        * If `allowOutOfRange` is true, this will allow the deserialization of
        * values greater than 0x2000000; larger values will be reported as an
        * error instead of being returned as a uint64.
        */
        fun parseCompactSize(rest: ByteArray, allowU64: Boolean): Pair<ULong, ByteArray> {
            if (rest.isEmpty()) {
                throw IllegalArgumentException("invalid compact size encoding")
            }
            val b = rest[0].toUByte()
            val n: ULong
            val remaining: ByteArray
        
            when (b) {
                253.toUByte() -> {
                    if (rest.size < 3) {
                        throw IllegalArgumentException("invalid compact size encoding")
                    }
                    n = binaryReadUint16(rest.copyOfRange(1, 3)).toULong()
                    remaining = rest.copyOfRange(3, rest.size)
                }
                254.toUByte() -> {
                    if (rest.size < 5) {
                        throw IllegalArgumentException("invalid compact size encoding")
                    }
                    n = binaryReadUint32(rest.copyOfRange(1, 5)).toULong()
                    remaining = rest.copyOfRange(5, rest.size)
                }
                255.toUByte() -> {
                    if (rest.size < 9) {
                        throw IllegalArgumentException("invalid compact size encoding")
                    }
                    n = binaryReadUint64(rest.copyOfRange(1, 9)).toULong()
                    remaining = rest.copyOfRange(9, rest.size)
                }
                else -> {
                    n = b.toULong()
                    remaining = rest.copyOfRange(1, rest.size)
                }
            }
        
            if (!allowU64 && n > maxCompactSize) {
                throw IllegalArgumentException("number exceeds maximum compact size")
            }
        
            return Pair(n, remaining)
        }

        fun binaryWrite(buf: ByteBuffer, n: Number) {
            when (n) {
                is Byte -> buf.put(n)
                is Short -> buf.putShort(n)
                is Int -> buf.putInt(n)
                is Long -> buf.putLong(n)
                else -> throw IllegalArgumentException("Unsupported type")
            }
        }

        // Function to read a UInt16 from a byte array in little-endian order
        fun binaryReadUint16(b: ByteArray): UShort {
            return ByteBuffer.wrap(b).order(ByteOrder.LITTLE_ENDIAN).short.toUShort()
        }

        // Function to read a UInt32 from a byte array in little-endian order
        fun binaryReadUint32(b: ByteArray): UInt {
            return ByteBuffer.wrap(b).order(ByteOrder.LITTLE_ENDIAN).int.toUInt()
        }

        // Function to read a UInt64 from a byte array in little-endian order
        fun binaryReadUint64(b: ByteArray): ULong {
            return ByteBuffer.wrap(b).order(ByteOrder.LITTLE_ENDIAN).long.toULong()
        }
    }
}
