/*
 * This source file was generated by the Gradle 'init' task
 */
package cash.z.zcashaddress

import fr.acinq.bitcoin.Bech32
import java.util.SortedMap
import java.util.TreeMap

enum class ItemType(val value: ULong) {
    P2PKHItem(0x00UL),
    P2SHItem(0x01UL),
    SaplingItem(0x02UL),
    OrchardItem(0x03UL);

    companion object {
        private val map = values().associateBy(ItemType::value)
        fun fromValue(value: ULong) = map[value]
    }
}

@OptIn(ExperimentalStdlibApi::class)
/**
 * A Zcash Unified Address.
 *
 * The `P2pkh` and `P2sh` fields of this structure are mutually exclusive; only one of these may be
 * non-nil.
 */
data class UnifiedAddress(
        val p2pkh: ByteArray? = null,
        val p2sh: ByteArray? = null,
        val sapling: ByteArray? = null,
        val orchard: ByteArray? = null,
        val unknown: SortedMap<ULong, ByteArray> = TreeMap()
) {
    companion object {
        fun getExpectedLength(itemType: ItemType): ULong {
            return when (itemType) {
                ItemType.P2PKHItem, ItemType.P2SHItem -> 20UL
                ItemType.SaplingItem, ItemType.OrchardItem -> 43UL
            }
        }

        fun getItemName(typeCode: ULong): String {
            return when (ItemType.values().find { it.value == typeCode }) {
                ItemType.P2PKHItem, ItemType.P2SHItem -> "transparent"
                ItemType.SaplingItem -> "sapling"
                ItemType.OrchardItem -> "orchard"
                null -> "unknown"
            }
        }

        fun tlv(typecode: ULong, value: ByteArray): ByteArray {
            val start = CompactSize.writeCompactSize(typecode, true)
            val simplified = value.size.toULong()
            val st = CompactSize.writeCompactSize(simplified, true)
            return start + st + value
        }

        fun padding(hrp: String): ByteArray {
            val hrpBytes = hrp.toByteArray()
            val padLength = 16 - hrpBytes.size
            val paddingBytes = ByteArray(if (padLength > 0) padLength else 0)
            return hrpBytes + paddingBytes
        }

        fun concatByteArrays(list: MutableList<ByteArray>): ByteArray {
            val totalSize = list.sumOf { it.size }
            val result = ByteArray(totalSize)
            var currentIndex = 0
            for (byteArray in list) {
                byteArray.copyInto(result, currentIndex)
                currentIndex += byteArray.size
            }
            return result
        }

        /**
         * Encodes a UnifiedAddress to its string representation as defined in [ZIP 316].
         *
         * This function will return an error if the UnifiedAddress contains both P2pkh and P2sh
         * receivers.
         *
         * [ZIP 316]: https:*zips.z.cash/zip-0316#encoding-of-unified-addresses
         */
        fun encodeUnified(addr: UnifiedAddress, hrp: String): String {
            require(addr.p2pkh == null || addr.p2sh == null) { "Both P2PKH and P2SH items found" }

            val encodedItems = mutableListOf<ByteArray>()

            addr.p2pkh?.let { encodedItems.add(tlv(ItemType.P2PKHItem.value, it)) }
            addr.p2sh?.let { encodedItems.add(tlv(ItemType.P2SHItem.value, it)) }
            addr.sapling?.let { encodedItems.add(tlv(ItemType.SaplingItem.value, it)) }
            addr.orchard?.let { encodedItems.add(tlv(ItemType.OrchardItem.value, it)) }

            addr.unknown.forEach { (itemType, item) ->
                if (item.isNotEmpty()) {
                    encodedItems.add(tlv(itemType, item))
                }
            }

            encodedItems.add(padding(hrp))
            val rBytes = concatByteArrays(encodedItems)

            val jumbledBytes = F4jumble.f4Jumble(rBytes)

            val converted = Bech32.eight2five(jumbledBytes)
            val encoded = Bech32.encode(hrp, converted, Bech32.Encoding.Bech32m)

            return encoded
        }

        /**
         * Decodes a UnifiedAddress from its string encoding as defined in [ZIP 316].
         *
         * This validates the encoded string against the provided expected human-readable part, and
         * returns an error if an unexpected HRP is encountered or if the encoding is invalid.
         *
         * [ZIP 316]: https:*zips.z.cash/zip-0316#encoding-of-unified-addresses
         */
        fun decodeUnified(encoded: String, expectedHrp: String): UnifiedAddress {
            val (hrp, data, _) =
                    try {
                        Bech32.decode(encoded.dropLast(6), true)
                    } catch (e: IllegalArgumentException) {
                        throw IllegalArgumentException("Invalid address format: ${e.message}")
                    }

            require(hrp == expectedHrp) { "Invalid HRP" }
            require(data.size >= 48) { "Invalid encoded data length" }

            val convertedBits = Bech32.five2eight(data, 0)

            val decoded = F4jumble.f4JumbleInv(convertedBits)

            val suffix = decoded.copyOfRange(decoded.size - 16, decoded.size)

            require(suffix contentEquals padding(expectedHrp)) { "Invalid trailing padding" }

            var rest = decoded.copyOfRange(0, decoded.size - 16).toMutableList()

            val receivers = mutableMapOf<ULong, ByteArray>()

            var prevType = -1

            while (rest.isNotEmpty()) {
                val (typeCode, rm) = CompactSize.parseCompactSize(rest.toByteArray(), true)
                val (itemLen, remaining) = CompactSize.parseCompactSize(rm, true)

                val itemType = ItemType.values().find { it.value == typeCode }
                if (itemType != null) {
                    val expectedLen = getExpectedLength(itemType)
                    require(expectedLen > 0UL && itemLen == expectedLen) {
                        "Incorrect item length for typecode $itemType"
                    }
                }

                val item = remaining.copyOfRange(0, itemLen.toInt())
                rest = remaining.copyOfRange(itemLen.toInt(), remaining.size).toMutableList()

                require(item.size == itemLen.toInt()) {
                    "Insufficient data for receiver with typecode $itemType"
                }

                require(typeCode !in receivers) {
                    "Duplicate ${getItemName(typeCode)} item detected"
                }
                receivers[typeCode] = item

                require(typeCode.toInt() > prevType) { "Items out of order" }
                prevType = typeCode.toInt()
            }

            var p2pkh: ByteArray? = null
            var p2sh: ByteArray? = null
            var sapling: ByteArray? = null
            var orchard: ByteArray? = null
            val unknown: SortedMap<ULong, ByteArray> = TreeMap()

            for ((typeCode, decodedData) in receivers) {
                when (ItemType.values().find { it.value == typeCode }) {
                    ItemType.P2PKHItem -> {
                        p2pkh = ByteArray(20)
                        System.arraycopy(decodedData, 0, p2pkh, 0, 20)
                    }
                    ItemType.P2SHItem -> {
                        p2sh = ByteArray(20)
                        System.arraycopy(decodedData, 0, p2sh, 0, 20)
                    }
                    ItemType.SaplingItem -> {
                        sapling = ByteArray(43)
                        System.arraycopy(decodedData, 0, sapling, 0, 43)
                    }
                    ItemType.OrchardItem -> {
                        orchard = ByteArray(43)
                        System.arraycopy(decodedData, 0, orchard, 0, 43)
                    }
                    null -> {
                        unknown.put(typeCode, decodedData)
                    }
                }
            }
            return UnifiedAddress(p2pkh, p2sh, sapling, orchard, unknown)
        }
    }
}
